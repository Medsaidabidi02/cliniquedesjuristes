# Phase 5: Security & Restrictions Implementation Guide

## Overview

This phase implements security measures to ensure only authorized users can access video content through private Hetzner Object Storage with signed URLs and optional access controls.

---

## 5.1 Private Hetzner Bucket Configuration

### Objective

Ensure the Hetzner Object Storage bucket is fully private with no public access. All video access must go through time-limited signed URLs generated by the backend.

### Implementation Steps

#### Step 1: Configure Hetzner Bucket as Private

**Using Hetzner Console:**

1. Log into your Hetzner Cloud Console
2. Navigate to Object Storage
3. Select your bucket: `clinique-videos`
4. Go to **Permissions** or **Access Control**
5. Set bucket policy to **Private**
6. Remove any public access rules
7. Ensure "Block Public Access" is enabled

**Using AWS CLI (S3-compatible):**

```bash
# Set bucket to private
aws s3api put-bucket-acl \
  --bucket clinique-videos \
  --acl private \
  --endpoint-url https://fsn1.your-objectstorage.com

# Block public access
aws s3api put-public-access-block \
  --bucket clinique-videos \
  --public-access-block-configuration \
    "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true" \
  --endpoint-url https://fsn1.your-objectstorage.com
```

**Verify Private Access:**

```bash
# Try to access file without signature (should fail)
curl https://fsn1.your-objectstorage.com/clinique-videos/videos/test.mp4
# Expected: 403 Forbidden or Access Denied

# Access with signed URL (should work)
curl "https://fsn1.your-objectstorage.com/clinique-videos/videos/test.mp4?Signature=..."
# Expected: 200 OK with video data
```

#### Step 2: Update Backend Configuration

Ensure the backend configuration enforces signed URLs:

**File: `backend/src/config/hetzner.ts`**

Already implemented with private access enforcement:

```typescript
export function getHetznerConfig(): HetznerConfig {
  // ... existing code
  
  return {
    endpoint: process.env.HETZNER_ENDPOINT!,
    region: process.env.HETZNER_REGION || 'fsn1',
    accessKeyId: process.env.HETZNER_ACCESS_KEY!,
    secretAccessKey: process.env.HETZNER_SECRET_KEY!,
    bucket: process.env.HETZNER_BUCKET!,
    forcePathStyle: true,
    // Private bucket - all access requires signed URLs
    useAccelerateEndpoint: false,
  };
}
```

#### Step 3: Verify Signed URL Implementation

The signed URL service (already implemented in Phase 2) ensures:

**File: `backend/src/services/signedUrl.ts`**

```typescript
// Generates AWS Signature Version 4
// - HMAC-SHA256 signing
// - Time-limited expiration (default 15 minutes)
// - Cannot be forged without secret key
// - Includes proper content-type headers

export async function generateSignedUrl(
  filePath: string,
  storageType: StorageType,
  expiresIn: number = 900
): Promise<SignedUrlResult> {
  // Implementation uses @aws-sdk/s3-request-presigner
  // Secure by default
}
```

### Security Validation Checklist

✅ Bucket is set to **Private** in Hetzner Console
✅ Public access is **Blocked** at bucket level
✅ Direct file URLs return **403 Forbidden**
✅ Signed URLs work with **200 OK**
✅ Signed URLs expire after configured time
✅ Expired URLs return **403 Forbidden**
✅ Invalid signatures return **403 Forbidden**

---

## 5.2 Optional Access Controls

### Overview

Additional security layers that can be enabled based on requirements.

### A. Country Restrictions (Cloudflare Level)

**Implementation Location:** Cloudflare Dashboard (not in application code)

**Steps:**

1. Log into Cloudflare Dashboard
2. Select your domain: `clinique-des-juristes.fr`
3. Go to **Firewall** → **Firewall Rules**
4. Create rule: "Block Countries"

**Rule Configuration:**

```
Field: Country
Operator: does not equal
Value: [Select allowed countries: FR, BE, LU, CH, etc.]
Action: Block
```

**Example Rule:**

```
(ip.geoip.country ne "FR" and 
 ip.geoip.country ne "BE" and 
 ip.geoip.country ne "CH")
```

**Why Cloudflare?**
- Applied at CDN edge (faster)
- No application code changes needed
- Works for all content types
- Centralized management

### B. Domain Referrer Check (Optional)

**Purpose:** Ensure video requests come from your domain only.

**Implementation:**

**File to Create: `backend/src/middleware/referrerCheck.ts`**

```typescript
import { Request, Response, NextFunction } from 'express';

export interface ReferrerCheckOptions {
  allowedDomains: string[];
  strict?: boolean; // Reject if no referrer
}

export function referrerCheck(options: ReferrerCheckOptions) {
  return (req: Request, res: Response, next: NextFunction) => {
    const referrer = req.get('referer') || req.get('referrer');
    
    // If no referrer and strict mode
    if (!referrer && options.strict) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'Direct access not allowed'
      });
    }
    
    // If referrer exists, check domain
    if (referrer) {
      const referrerUrl = new URL(referrer);
      const referrerHost = referrerUrl.hostname;
      
      const isAllowed = options.allowedDomains.some(domain => {
        return referrerHost === domain || 
               referrerHost.endsWith(`.${domain}`);
      });
      
      if (!isAllowed) {
        return res.status(403).json({
          error: 'Forbidden',
          message: 'Access from unauthorized domain'
        });
      }
    }
    
    next();
  };
}
```

**Usage in Routes:**

```typescript
// File: backend/src/routes/videos.ts

import { referrerCheck } from '../middleware/referrerCheck';

const referrerMiddleware = referrerCheck({
  allowedDomains: [
    'clinique-des-juristes.fr',
    'localhost' // For development
  ],
  strict: false // Allow missing referrer (mobile apps)
});

// Apply to video routes
router.get('/videos/:id/playback-info', 
  authenticate, 
  referrerMiddleware, // Add here
  getPlaybackInfo
);
```

**Configuration:**

```env
# .env
ENABLE_REFERRER_CHECK=false  # Set to true to enable
ALLOWED_DOMAINS=clinique-des-juristes.fr,localhost
REFERRER_CHECK_STRICT=false
```

**Limitations:**
- Referrer can be spoofed
- Some browsers/privacy tools strip referrer
- Not reliable for mobile apps
- Recommended: Use as additional layer, not primary security

### C. IP/Session Binding (Advanced Mode)

**Purpose:** Bind signed URLs to the requesting IP address and session.

**Security Benefits:**
- Prevents URL sharing
- Limits concurrent streams
- Detects token theft

**Implementation:**

**File to Create: `backend/src/services/sessionBinding.ts`**

```typescript
import crypto from 'crypto';

export interface SessionBindingOptions {
  includeIp: boolean;
  includeUserAgent: boolean;
  includeSessionId: boolean;
}

export function generateBindingToken(
  req: Express.Request,
  options: SessionBindingOptions
): string {
  const components: string[] = [];
  
  if (options.includeIp) {
    const ip = req.ip || req.connection.remoteAddress || '';
    components.push(ip);
  }
  
  if (options.includeUserAgent) {
    const ua = req.get('user-agent') || '';
    components.push(ua);
  }
  
  if (options.includeSessionId) {
    const sessionId = req.session?.id || '';
    components.push(sessionId);
  }
  
  const combined = components.join('|');
  return crypto
    .createHash('sha256')
    .update(combined)
    .digest('hex')
    .substring(0, 16);
}

export function validateBindingToken(
  req: Express.Request,
  providedToken: string,
  options: SessionBindingOptions
): boolean {
  const expectedToken = generateBindingToken(req, options);
  return expectedToken === providedToken;
}
```

**Enhanced Signed URL Service:**

**File to Update: `backend/src/services/signedUrl.ts`**

Add session binding to signed URLs:

```typescript
export async function generateSignedUrlWithBinding(
  filePath: string,
  storageType: StorageType,
  req: Express.Request,
  expiresIn: number = 900
): Promise<SignedUrlResult> {
  const baseUrl = await generateSignedUrl(filePath, storageType, expiresIn);
  
  // Add binding token to URL
  const bindingToken = generateBindingToken(req, {
    includeIp: true,
    includeUserAgent: false,
    includeSessionId: true
  });
  
  const url = new URL(baseUrl.url);
  url.searchParams.append('bt', bindingToken); // binding token
  
  return {
    ...baseUrl,
    url: url.toString(),
    bindingToken
  };
}
```

**Validation Middleware:**

```typescript
// File: backend/src/middleware/validateBinding.ts

export function validateSessionBinding() {
  return (req: Request, res: Response, next: NextFunction) => {
    const bindingToken = req.query.bt as string;
    
    if (!bindingToken) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'Invalid request'
      });
    }
    
    const isValid = validateBindingToken(req, bindingToken, {
      includeIp: true,
      includeUserAgent: false,
      includeSessionId: true
    });
    
    if (!isValid) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'Session binding validation failed'
      });
    }
    
    next();
  };
}
```

**Configuration:**

```env
# .env
ENABLE_SESSION_BINDING=false  # Advanced mode
SESSION_BINDING_IP=true
SESSION_BINDING_UA=false  # User agent changes often
SESSION_BINDING_SESSION=true
```

**Limitations:**
- User IP can change (mobile networks, VPN)
- Breaks legitimate device switching
- More complex to debug
- Recommended: Use only for high-security requirements

---

## Security Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    User Request                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Cloudflare (Layer 1)                       │
│  - Country restrictions (if enabled)                    │
│  - DDoS protection                                      │
│  - CDN caching                                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           Backend API (Layer 2)                         │
│  - JWT authentication (required)                        │
│  - Course/subject access control                        │
│  - Referrer check (if enabled)                          │
│  - Rate limiting                                        │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│        Generate Signed URL (Layer 3)                    │
│  - AWS Signature v4 (HMAC-SHA256)                       │
│  - Time-limited (15 minutes)                            │
│  - Session binding (if enabled)                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│         Hetzner Object Storage (Layer 4)                │
│  - Private bucket (no public access)                    │
│  - Validates signature                                  │
│  - Validates expiration                                 │
│  - Returns video content                                │
└─────────────────────────────────────────────────────────┘
```

---

## Configuration Matrix

| Security Feature | Level | Enabled By Default | Configuration Required | Impact on UX |
|-----------------|-------|-------------------|----------------------|--------------|
| Private Bucket | Critical | ✅ Yes | Hetzner Console | None |
| Signed URLs | Critical | ✅ Yes | None (automatic) | None |
| JWT Authentication | Critical | ✅ Yes | None (existing) | None |
| Access Control | Critical | ✅ Yes | None (existing) | None |
| Token Refresh | High | ✅ Yes | None (Phase 3) | None |
| Country Restrictions | Medium | ❌ No | Cloudflare | May block VPN users |
| Referrer Check | Low | ❌ No | Backend env vars | May block mobile apps |
| Session Binding | Low | ❌ No | Backend env vars | Breaks device switching |

---

## Environment Variables Summary

```env
# Critical Security (Always Required)
ENABLE_HETZNER=true
HETZNER_ENDPOINT=https://fsn1.your-objectstorage.com
HETZNER_ACCESS_KEY=your-access-key
HETZNER_SECRET_KEY=your-secret-key
HETZNER_BUCKET=clinique-videos

# Video Security (Required)
VIDEO_URL_EXPIRATION=900       # 15 minutes
VIDEO_TOKEN_LIFETIME=1800      # 30 minutes
TOKEN_REFRESH_THRESHOLD=0.8    # Refresh at 80%

# Optional Security Features
ENABLE_REFERRER_CHECK=false
ALLOWED_DOMAINS=clinique-des-juristes.fr
REFERRER_CHECK_STRICT=false

ENABLE_SESSION_BINDING=false
SESSION_BINDING_IP=true
SESSION_BINDING_UA=false
SESSION_BINDING_SESSION=true

# Rate Limiting
MAX_TOKEN_REFRESHES_PER_HOUR=10
MAX_VIDEO_REQUESTS_PER_MINUTE=20
```

---

## Testing Security

### Test 1: Private Bucket

```bash
# Should FAIL (403 Forbidden)
curl https://fsn1.your-objectstorage.com/clinique-videos/videos/test.mp4

# Should SUCCEED (200 OK)
curl "https://fsn1.your-objectstorage.com/clinique-videos/videos/test.mp4?X-Amz-Signature=..."
```

### Test 2: Signed URL Expiration

```bash
# Generate URL with 60-second expiration
# Wait 61 seconds
# Try to access

# Expected: 403 Forbidden (expired)
```

### Test 3: Invalid Signature

```bash
# Generate valid signed URL
# Modify signature parameter
# Try to access

# Expected: 403 Forbidden (invalid signature)
```

### Test 4: Referrer Check (if enabled)

```bash
# Without referrer
curl https://api.example.com/api/videos/123/playback-info

# Expected: 403 (if strict mode)

# With valid referrer
curl -H "Referer: https://clinique-des-juristes.fr" \
     https://api.example.com/api/videos/123/playback-info

# Expected: 200 OK

# With invalid referrer
curl -H "Referer: https://malicious-site.com" \
     https://api.example.com/api/videos/123/playback-info

# Expected: 403 Forbidden
```

### Test 5: Session Binding (if enabled)

```bash
# Generate URL from IP 1.2.3.4
# Try to access from IP 5.6.7.8

# Expected: 403 Forbidden (IP mismatch)
```

---

## Deployment Checklist

### Before Production

- [ ] Set Hetzner bucket to **Private**
- [ ] Enable **Block Public Access** on bucket
- [ ] Verify signed URLs work
- [ ] Test URL expiration (15 minutes)
- [ ] Configure Cloudflare country rules (if needed)
- [ ] Set up monitoring for 403 errors
- [ ] Document allowed countries/domains
- [ ] Test from multiple browsers
- [ ] Test from mobile devices
- [ ] Verify token refresh works
- [ ] Check performance impact
- [ ] Set up error logging

### In Production

- [ ] Monitor 403 error rates
- [ ] Check signed URL generation times
- [ ] Verify no public bucket access
- [ ] Monitor token refresh success rate
- [ ] Review security logs weekly
- [ ] Update security rules as needed

---

## Troubleshooting

### Issue: Videos not playing

**Check:**
1. Is Hetzner bucket private? ✅
2. Are signed URLs being generated? ✅
3. Are URLs expiring too quickly? (Check VIDEO_URL_EXPIRATION)
4. Is token refresh working? (Check browser console)
5. Are there CORS issues? (Check Hetzner CORS policy)

### Issue: 403 Forbidden errors

**Common Causes:**
1. Expired signed URL → Enable token refresh (Phase 3)
2. Invalid signature → Check Hetzner credentials
3. Public access blocked → This is correct! Use signed URLs
4. Referrer check failing → Disable or add domain to whitelist
5. Session binding failing → Disable or check IP changes

### Issue: Slow video loading

**Optimize:**
1. Reduce VIDEO_URL_EXPIRATION to 10 minutes
2. Enable Cloudflare CDN caching
3. Use HLS for adaptive bitrate
4. Check Hetzner region (use closest to users)
5. Enable video compression

---

## Best Practices

1. **Always use signed URLs** - Never expose direct Hetzner URLs
2. **Keep expiration short** - 15 minutes is recommended
3. **Enable token refresh** - Implemented in Phase 3
4. **Monitor security logs** - Track 403 errors and patterns
5. **Test from different IPs** - Ensure session binding doesn't break UX
6. **Document security rules** - Keep this guide updated
7. **Regular security audits** - Review access patterns monthly
8. **Rotate credentials** - Change Hetzner keys periodically
9. **Use HTTPS only** - No HTTP for video requests
10. **Rate limit API** - Prevent abuse of signed URL generation

---

## Next Steps

After Phase 5 security implementation, proceed to:

1. **Phase 6: Testing** - Comprehensive test suite (see PHASE_6_TESTING_GUIDE.md)
2. **Phase 7: Documentation** - User guides and deployment docs
3. **Production Deployment** - Gradual rollout with monitoring

---

## Support & References

**Documentation:**
- AWS Signature v4: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html
- Hetzner Object Storage: https://docs.hetzner.com/storage/object-storage/
- Cloudflare Firewall: https://developers.cloudflare.com/firewall/

**Files Modified/Created:**
- `backend/src/middleware/referrerCheck.ts` (optional)
- `backend/src/services/sessionBinding.ts` (optional)
- `backend/src/middleware/validateBinding.ts` (optional)

**Configuration:**
- See `.env.example` for all security variables
- See `backend/src/config/video.ts` for default values

---

**Phase 5 Status**: Documentation Complete ✅
**Implementation**: Optional features documented (enable as needed)
**Security Level**: High (with private bucket + signed URLs)
**Ready for**: Phase 6 Testing
